{
	"HynDufCP": {
		"prefix": "YORU",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#ifdef HynDuf",
			"\t#include \"../debug.h\"",
			"#else",
			"\t#define debug(...)",
			"\t#define debugArr(...)",
			"#endif",
			"#define sz(x) ((int) (x).size())",
			"#define all(v) (v).begin(), (v).end()",
			"#define fi first",
			"#define se second",
			"",
			"using namespace std;",
			"using ll = long long;",
			"using ld = long double;",
			"using ii = pair<int, int>;",
			"using vi = vector<int>;",
			"",
			"int main() {",
			"\tcin.tie(0)->sync_with_stdio(0);",
			"\t$0",
			"\treturn 0;",
			"}"
		],
		"description": "HynDufCP"
	},
	"HynDufTime": {
		"prefix": "HynDufTime",
		"body": [
			"#ifdef HynDuf",
			"    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";",
			"#endif"
		],
		"description": "HynDufTime"
	},
	"SimpleCPTemplate": {
		"prefix": "YORU_SIMP",
		"body": [
			"#include <bits/stdc++.h>",
			" ",
			"using namespace std;",
			" ",
			"using ll = long long;",
			"using ld = long double;",
			"using ii = pair<int, int>;",
			"using vi = vector<int>;",
			"",
			"int main() {",
			"\tcin.tie(0)->sync_with_stdio(0);",
			"\t$0",
			"\treturn 0;",
			"}"
		],
		"description": "Simple CP Template"
	},
	"TwoSAT": {
		"prefix": "TWOSAT",
		"body": [
			"/**",
			" * Author: Emil Lenngren, Simon Lindholm",
			" * Date: 2011-11-29",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Calculates a valid assignment to boolean variables a, b, c,... to a 2-SAT problem,",
			" * so that an expression of the type $(a\\|\\|b)\\&\\&(!a\\|\\|c)\\&\\&(d\\|\\|!b)\\&\\&...$ becomes true, or reports that it is unsatisfiable.",
			" * Negated variables are represented by bit-inversions (\\texttt{~x}).",
			" * Usage:",
			" *  TwoSat ts(number of boolean variables);",
			" *  ts.either(0, ~3); // Var 0 is true or var 3 is false",
			" *  ts.setValue(2); // Var 2 is true",
			" *  ts.atMostOne({0,~1,2}); // <= 1 of vars 0, ~1 and 2 are true",
			" *  ts.solve(); // Returns true iff it is solvable",
			" *  ts.values[0..N-1] holds the assigned values to the vars",
			" * Time: O(N+E), where N is the number of boolean variables, and E is the number of clauses.",
			" * Status: stress-tested",
			" */",
			"",
			"struct TwoSat {",
			"	int N;",
			"	vector<vi> gr;",
			"	vi values; // 0 = false, 1 = true",
			"",
			"	TwoSat(int n = 0) : N(n), gr(2*n) {}",
			"",
			"	int addVar() { // (optional)",
			"		gr.emplace_back();",
			"		gr.emplace_back();",
			"		return N++;",
			"	}",
			"",
			"	void either(int f, int j) {",
			"		f = max(2*f, -1-2*f);",
			"		j = max(2*j, -1-2*j);",
			"		gr[f].push_back(j^1);",
			"		gr[j].push_back(f^1);",
			"	}",
			"	void setValue(int x) { either(x, x); }",
			"",
			"	void atMostOne(const vi& li) { // (optional)",
			"		if (sz(li) <= 1) return;",
			"		int cur = ~li[0];",
			"		rep(i,2,sz(li)) {",
			"			int next = addVar();",
			"			either(cur, ~li[i]);",
			"			either(cur, next);",
			"			either(~li[i], next);",
			"			cur = ~next;",
			"		}",
			"		either(cur, ~li[1]);",
			"	}",
			"",
			"	vi val, comp, z; int time = 0;",
			"	int dfs(int i) {",
			"		int low = val[i] = ++time, x; z.push_back(i);",
			"		for(int e : gr[i]) if (!comp[e])",
			"			low = min(low, val[e] ?: dfs(e));",
			"		if (low == val[i]) do {",
			"			x = z.back(); z.pop_back();",
			"			comp[x] = low;",
			"			if (values[x>>1] == -1)",
			"				values[x>>1] = x&1;",
			"		} while (x != i);",
			"		return val[i] = low;",
			"	}",
			"",
			"	bool solve() {",
			"		values.assign(N, -1);",
			"		val.assign(2*N, 0); comp = val;",
			"		rep(i,0,2*N) if (!comp[i]) dfs(i);",
			"		rep(i,0,N) if (comp[2*i] == comp[2*i+1]) return 0;",
			"		return 1;",
			"	}",
			"};",
			""
		],
		"description": "TwoSAT"
	},
	"KACTL": {
		"prefix": "KACTL",
		"body": [
			"#define rep(i, a, b) for(int i = a; i < (b); ++i)",
			"typedef pair<int, int> pii;"
		],
		"description": "KACTL"
	},
	"FenwickTree": {
		"prefix": "FENWICKTREE",
		"body": [
			"/**",
			" * Author: Lukas Polacek",
			" * Date: 2009-10-30",
			" * License: CC0",
			" * Source: folklore/TopCoder",
			" * Description: Computes partial sums a[0] + a[1] + ... + a[pos - 1], and updates single elements a[i],",
			" * taking the difference between the old and new value.",
			" * Time: Both operations are $O(\\log N)$.",
			" * Status: Stress-tested",
			" */",
			"struct FT {",
			"	vector<ll> s;",
			"	FT(int n) : s(n) {}",
			"	void update(int pos, ll dif) { // a[pos] += dif",
			"		for (; pos < sz(s); pos |= pos + 1) s[pos] += dif;",
			"	}",
			"	ll query(int pos) { // sum of values in [0, pos)",
			"		ll res = 0;",
			"		for (; pos > 0; pos &= pos - 1) res += s[pos-1];",
			"		return res;",
			"	}",
			"	int lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum",
			"		// Returns n if no sum is >= sum, or -1 if empty sum is.",
			"		if (sum <= 0) return -1;",
			"		int pos = 0;",
			"		for (int pw = 1 << 25; pw; pw >>= 1) {",
			"			if (pos + pw <= sz(s) && s[pos + pw-1] < sum)",
			"				pos += pw, sum -= s[pos-1];",
			"		}",
			"		return pos;",
			"	}",
			"};"
		],
		"description": "FenwickTree"
	},
	"RMQ": {
		"prefix": "RMQ",
		"body": [
			"// usage:",
			"//   auto fun = [&](int i, int j) { return min(i, j); };",
			"//   SparseTable<int, decltype(fun)> st(a, fun);",
			"// or:",
			"//   SparseTable<int> st(a, [&](int i, int j) { return min(i, j); });",
			"template <typename T, class F = function<T(const T&, const T&)>>",
			"class SparseTable {",
			" public:",
			"  int _n;",
			"  vector<vector<T>> mat;",
			"  F func;",
			"",
			"  SparseTable(const vector<T>& a, const F& f) : func(f) {",
			"    _n = static_cast<int>(a.size());",
			"    int max_log = 32 - __builtin_clz(_n);",
			"    mat.resize(max_log);",
			"    mat[0] = a;",
			"    for (int j = 1; j < max_log; j++) {",
			"      mat[j].resize(_n - (1 << j) + 1);",
			"      for (int i = 0; i <= _n - (1 << j); i++) {",
			"        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);",
			"      }",
			"    }",
			"  }",
			"",
			"  T get(int from, int to) const {",
			"    assert(0 <= from && from <= to && to <= _n - 1);",
			"    int lg = 32 - __builtin_clz(to - from + 1) - 1;",
			"    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);",
			"  }",
			"};"
		],
		"description": "RMQ"
	},
	"DSU": {
		"prefix": "DSU",
		"body": [
			"/**",
			" * Author: Lukas Polacek",
			" * Date: 2009-10-26",
			" * License: CC0",
			" * Source: folklore",
			" * Description: Disjoint-set data structure.",
			" * Time: $O(\\alpha(N))$",
			" */",
			"struct UF {",
			"	vi e;",
			"	UF(int n) : e(n, -1) {}",
			"	bool sameSet(int a, int b) { return find(a) == find(b); }",
			"	int size(int x) { return -e[find(x)]; }",
			"	int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }",
			"	bool join(int a, int b) {",
			"		a = find(a), b = find(b);",
			"		if (a == b) return false;",
			"		if (e[a] > e[b]) swap(a, b);",
			"		e[a] += e[b]; e[b] = a;",
			"		return true;",
			"	}",
			"};"
		],
		"description": "DSU"
	},
	"MCMF": {
		"prefix": "MCMF",
		"body": [
			"/**",
			" * Author: Stanford",
			" * Date: Unknown",
			" * Source: Stanford Notebook",
			" * Description: Min-cost max-flow. cap[i][j] != cap[j][i] is allowed; double edges are not.",
			" *  If costs can be negative, call setpi before maxflow, but note that negative cost cycles are not supported.",
			" *  To obtain the actual flow, look at positive values only.",
			" * Status: Tested on kattis:mincostmaxflow, stress-tested against another implementation",
			" * Time: Approximately O(E^2)",
			" */",
			"#include <bits/extc++.h> /// include-line, keep-include",
			"",
			"const ll INF = numeric_limits<ll>::max() / 4;",
			"typedef vector<ll> VL;",
			"",
			"struct MCMF {",
			"	int N;",
			"	vector<vi> ed, red;",
			"	vector<VL> cap, flow, cost;",
			"	vi seen;",
			"	VL dist, pi;",
			"	vector<pii> par;",
			"",
			"	MCMF(int N) :",
			"		N(N), ed(N), red(N), cap(N, VL(N)), flow(cap), cost(cap),",
			"		seen(N), dist(N), pi(N), par(N) {}",
			"",
			"	void addEdge(int from, int to, ll cap, ll cost) {",
			"		this->cap[from][to] = cap;",
			"		this->cost[from][to] = cost;",
			"		ed[from].push_back(to);",
			"		red[to].push_back(from);",
			"	}",
			"",
			"	void path(int s) {",
			"		fill(all(seen), 0);",
			"		fill(all(dist), INF);",
			"		dist[s] = 0; ll di;",
			"",
			"		__gnu_pbds::priority_queue<pair<ll, int>> q;",
			"		vector<decltype(q)::point_iterator> its(N);",
			"		q.push({0, s});",
			"",
			"		auto relax = [&](int i, ll cap, ll cost, int dir) {",
			"			ll val = di - pi[i] + cost;",
			"			if (cap && val < dist[i]) {",
			"				dist[i] = val;",
			"				par[i] = {s, dir};",
			"				if (its[i] == q.end()) its[i] = q.push({-dist[i], i});",
			"				else q.modify(its[i], {-dist[i], i});",
			"			}",
			"		};",
			"",
			"		while (!q.empty()) {",
			"			s = q.top().second; q.pop();",
			"			seen[s] = 1; di = dist[s] + pi[s];",
			"			for (int i : ed[s]) if (!seen[i])",
			"				relax(i, cap[s][i] - flow[s][i], cost[s][i], 1);",
			"			for (int i : red[s]) if (!seen[i])",
			"				relax(i, flow[i][s], -cost[i][s], 0);",
			"		}",
			"		rep(i,0,N) pi[i] = min(pi[i] + dist[i], INF);",
			"	}",
			"",
			"	pair<ll, ll> maxflow(int s, int t) {",
			"		ll totflow = 0, totcost = 0;",
			"		while (path(s), seen[t]) {",
			"			ll fl = INF;",
			"			for (int p,r,x = t; tie(p,r) = par[x], x != s; x = p)",
			"				fl = min(fl, r ? cap[p][x] - flow[p][x] : flow[x][p]);",
			"			totflow += fl;",
			"			for (int p,r,x = t; tie(p,r) = par[x], x != s; x = p)",
			"				if (r) flow[p][x] += fl;",
			"				else flow[x][p] -= fl;",
			"		}",
			"		rep(i,0,N) rep(j,0,N) totcost += cost[i][j] * flow[i][j];",
			"		return {totflow, totcost};",
			"	}",
			"",
			"	// If some costs can be negative, call this before maxflow:",
			"	void setpi(int s) { // (otherwise, leave this out)",
			"		fill(all(pi), INF); pi[s] = 0;",
			"		int it = N, ch = 1; ll v;",
			"		while (ch-- && it--)",
			"			rep(i,0,N) if (pi[i] != INF)",
			"				for (int to : ed[i]) if (cap[i][to])",
			"					if ((v = pi[i] + cost[i][to]) < pi[to])",
			"						pi[to] = v, ch = 1;",
			"		assert(it >= 0); // negative cost cycle",
			"	}",
			"};"
		],
		"description": "MCMF"
	},
	"Dinic": {
		"prefix": "DINIC",
		"body": [
			"/**",
			" * Author: chilli",
			" * Date: 2019-04-26",
			" * License: CC0",
			" * Source: https://cp-algorithms.com/graph/dinic.html",
			" * Description: Flow algorithm with complexity $O(VE\\log U)$ where $U = \\max |\\text{cap}|$.",
			" * $O(\\min(E^{1/2}, V^{2/3})E)$ if $U = 1$; $O(\\sqrt{V}E)$ for bipartite matching.",
			" * Status: Tested on SPOJ FASTFLOW and SPOJ MATCHING, stress-tested",
			" */",
			"",
			"struct Dinic {",
			"	struct Edge {",
			"		int to, rev;",
			"		ll c, oc;",
			"		ll flow() { return max(oc - c, 0LL); } // if you need flows",
			"	};",
			"	vi lvl, ptr, q;",
			"	vector<vector<Edge>> adj;",
			"	Dinic(int n) : lvl(n), ptr(n), q(n), adj(n) {}",
			"	void addEdge(int a, int b, ll c, ll rcap = 0) {",
			"		adj[a].push_back({b, sz(adj[b]), c, c});",
			"		adj[b].push_back({a, sz(adj[a]) - 1, rcap, rcap});",
			"	}",
			"	ll dfs(int v, int t, ll f) {",
			"		if (v == t || !f) return f;",
			"		for (int& i = ptr[v]; i < sz(adj[v]); i++) {",
			"			Edge& e = adj[v][i];",
			"			if (lvl[e.to] == lvl[v] + 1)",
			"				if (ll p = dfs(e.to, t, min(f, e.c))) {",
			"					e.c -= p, adj[e.to][e.rev].c += p;",
			"					return p;",
			"				}",
			"		}",
			"		return 0;",
			"	}",
			"	ll calc(int s, int t) {",
			"		ll flow = 0; q[0] = s;",
			"		rep(L,0,31) do { // 'int L=30' maybe faster for random data",
			"			lvl = ptr = vi(sz(q));",
			"			int qi = 0, qe = lvl[s] = 1;",
			"			while (qi < qe && !lvl[t]) {",
			"				int v = q[qi++];",
			"				for (Edge e : adj[v])",
			"					if (!lvl[e.to] && e.c >> (30 - L))",
			"						q[qe++] = e.to, lvl[e.to] = lvl[v] + 1;",
			"			}",
			"			while (ll p = dfs(s, t, LLONG_MAX)) flow += p;",
			"		} while (lvl[t]);",
			"		return flow;",
			"	}",
			"	bool leftOfMinCut(int a) { return lvl[a] != 0; }",
			"};"
		],
		"description": "Dinic"
	},
	"SegTree": {
		"prefix": "SEGTREE",
		"body": [
			"template <typename T, typename Combine>",
			"struct SegTree {",
			"    const T identity;",
			"    std::vector<T> f;",
			"    const Combine combine;",
			"    SegTree(int n, const T identity, const Combine &combine_) : identity(identity), f(n * 4, identity), combine(combine_) {}",
			"    void init(int n, T val) {",
			"        f.assign(n * 4, val);",
			"    }",
			"    template <typename H>",
			"    void build(int x, int lo, int hi, const H &construct) {",
			"        if (lo == hi) {",
			"            f[x] = construct(lo);",
			"            return;",
			"        }",
			"        int mid = (lo + hi) / 2;",
			"        build(x * 2, lo, mid, construct);",
			"        build(x * 2 + 1, mid + 1, hi, construct);",
			"        f[x] = combine(f[x * 2], f[x * 2 + 1]);",
			"    }",
			"    void set(int x, int lo, int hi, int idx, const T &val) {",
			"        if (lo == hi) {",
			"            f[x] = val;",
			"            return;",
			"        }",
			"        int mid = (lo + hi) / 2;",
			"        if (idx <= mid) {",
			"            set(x * 2, lo, mid, idx, val);",
			"        } else {",
			"            set(x * 2 + 1, mid + 1, hi, idx, val);",
			"        }",
			"        f[x] = combine(f[x * 2], f[x * 2 + 1]);",
			"    }",
			"    void update(int x, int lo, int hi, int idx, const T &val) {",
			"        if (lo == hi) {",
			"            f[x] = combine(f[x], val);",
			"            return;",
			"        }",
			"        int mid = (lo + hi) / 2;",
			"        if (idx <= mid) {",
			"            update(x * 2, lo, mid, idx, val);",
			"        } else {",
			"            update(x * 2 + 1, mid + 1, hi, idx, val);",
			"        }",
			"        f[x] = combine(f[x * 2], f[x * 2 + 1]);",
			"    }",
			"    T query(int x, int lo, int hi, int L, int R) const {",
			"        if (lo > R || hi < L) {",
			"            return identity;",
			"        }",
			"        if (lo >= L && hi <= R) {",
			"            return f[x];",
			"        }",
			"        int mid = (lo + hi) / 2;",
			"        return combine(query(x * 2, lo, mid, L, R), query(x * 2 + 1, mid + 1, hi, L, R));",
			"    }",
			"    template <typename C>",
			"    pair<int, bool> find_first(int x, int lo, int hi, C cond) {",
			"        if (!cond(f[x])) {",
			"            return {hi + 1, 0};",
			"        }",
			"        if (lo == hi) {",
			"            return {hi, 1};",
			"        }",
			"        int mid = (lo + hi) / 2;",
			"        pair<int, bool> ret = find_first(x * 2, lo, mid, cond);",
			"        if (ret.second) {",
			"            return ret;",
			"        }",
			"        return find_first(x * 2 + 1, mid + 1, hi, cond);",
			"    }",
			"    template <typename C>",
			"    pair<int, bool> find_first(int x, int lo, int hi, int L, int R, C cond) {",
			"        if (lo > R || hi < L) {",
			"            return {hi + 1, 0};",
			"        }",
			"        if (lo >= L && hi <= R) {",
			"            if (cond(f[x])) {",
			"                return find_first(x, lo, hi, cond);",
			"            }",
			"            return {hi + 1, 0};",
			"        }",
			"        int mid = (lo + hi) / 2;",
			"        pair<int, bool> ret = find_first(x * 2, lo, mid, L, R, cond);",
			"        if (ret.second) {",
			"            return ret;",
			"        }",
			"        return find_first(x * 2 + 1, mid + 1, hi, L, R, cond);",
			"    }",
			"    template <typename C>",
			"    pair<int, bool> find_last(int x, int lo, int hi, C cond) {",
			"        if (!cond(f[x])) {",
			"            return {lo - 1, 0};",
			"        }",
			"        if (lo == hi) {",
			"            return {lo, 1};",
			"        }",
			"        int mid = (lo + hi) / 2;",
			"        pair<int, bool> ret = find_last(x * 2 + 1, mid + 1, hi, cond);",
			"        if (ret.second) {",
			"            return ret;",
			"        }",
			"        return find_last(x * 2, lo, mid, cond);",
			"    }",
			"    template <typename C>",
			"    pair<int, bool> find_last(int x, int lo, int hi, int L, int R, C cond) {",
			"        if (lo > R || hi < L) {",
			"            return {lo - 1, 0};",
			"        }",
			"        if (lo >= L && hi <= R) {",
			"            if (cond(f[x])) {",
			"                return find_last(x, lo, hi, cond);",
			"            }",
			"            return {lo - 1, 0};",
			"        }",
			"        int mid = (lo + hi) / 2;",
			"        pair<int, bool> ret = find_last(x * 2 + 1, mid + 1, hi, L, R, cond);",
			"        if (ret.second) {",
			"            return ret;",
			"        }",
			"        return find_last(x * 2, lo, mid, L, R, cond);",
			"    }",
			"};",
			"template <class T, class Combine>",
			"SegTree<T, Combine> makeSegTree(int n, const T identity, const Combine &combine) {",
			"    return SegTree<T, Combine>(n, identity, combine);",
			"}"
		],
		"description": "SegTree"
	},
	"LazySegTree": {
		"prefix": "LAZYSEGTREE",
		"body": [
			"template <class T, class F, class Combine, class Compose>",
			"struct LazySegTree {",
			"    const T identity;",
			"    const F lazy_identity;",
			"    std::vector<T> f;",
			"    std::vector<F> lazy;",
			"    const Combine combine;",
			"    const Compose compose;",
			"    LazySegTree(int n, const T identity_, const F &lazy_identity_, const Combine &combine_, Compose const &compose_) : identity(identity_), lazy_identity(lazy_identity_), f(n * 4, identity_), lazy(n * 4, lazy_identity_), combine(combine_), compose(compose_) {}",
			"    void init(int n, T val) {",
			"        f.assign(n * 4, val);",
			"        lazy.assign(n * 4, lazy_identity);",
			"    }",
			"    template <class H>",
			"    void build(int x, int lo, int hi, const H &construct) {",
			"        lazy[x] = lazy_identity;",
			"        if (lo == hi) {",
			"            f[x] = construct(lo);",
			"            return;",
			"        }",
			"        int mid = (lo + hi) / 2;",
			"        build(x * 2, lo, mid, construct);",
			"        build(x * 2 + 1, mid + 1, hi, construct);",
			"        f[x] = combine(f[x * 2], f[x * 2 + 1]);",
			"    }",
			"    void down(int x) {",
			"        if (lazy[x] != lazy_identity) {",
			"            compose(lazy[x], f[x * 2], lazy[x * 2]);",
			"            compose(lazy[x], f[x * 2 + 1], lazy[x * 2 + 1]);",
			"            lazy[x] = lazy_identity;",
			"        }",
			"    }",
			"    void set(int x, int lo, int hi, int idx, const T &val) {",
			"        if (lo == hi) {",
			"            f[x] = val;",
			"            return;",
			"        }",
			"        down(x);",
			"        int mid = (lo + hi) / 2;",
			"        if (idx <= mid) {",
			"            set(x * 2, lo, mid, idx, val);",
			"        } else {",
			"            set(x * 2 + 1, mid + 1, hi, idx, val);",
			"        }",
			"        f[x] = combine(f[x * 2], f[x * 2 + 1]);",
			"    }",
			"    void update(int x, int lo, int hi, int idx, const T &val) {",
			"        if (lo == hi) {",
			"            f[x] = combine(f[x], val);",
			"            return;",
			"        }",
			"        down(x);",
			"        int mid = (lo + hi) / 2;",
			"        if (idx <= mid) {",
			"            update(x * 2, lo, mid, idx, val);",
			"        } else {",
			"            update(x * 2 + 1, mid + 1, hi, idx, val);",
			"        }",
			"        f[x] = combine(f[x * 2], f[x * 2 + 1]);",
			"    }",
			"    void update(int x, int lo, int hi, int L, int R, const F &val) {",
			"        if (lo > R || hi < L) {",
			"            return;",
			"        }",
			"        if (lo >= L && hi <= R) {",
			"            compose(val, f[x], lazy[x]);",
			"            return;",
			"        }",
			"        down(x);",
			"        int mid = (lo + hi) / 2;",
			"        update(x * 2, lo, mid, L, R, val);",
			"        update(x * 2 + 1, mid + 1, hi, L, R, val);",
			"        f[x] = combine(f[x * 2], f[x * 2 + 1]);",
			"    }",
			"    T query(int x, int lo, int hi, int L, int R) {",
			"        if (lo > R || hi < L) {",
			"            return identity;",
			"        }",
			"        if (lo >= L && hi <= R) {",
			"            return f[x];",
			"        }",
			"        down(x);",
			"        int mid = (lo + hi) / 2;",
			"        return combine(query(x * 2, lo, mid, L, R), query(x * 2 + 1, mid + 1, hi, L, R));",
			"    }",
			"};",
			"template <class T, class F, class Combine, class Compose>",
			"LazySegTree<T, F, Combine, Compose> makeLazySegTree(int n, const T identity, const F &lazy_identity, const Combine &combine, const Compose &compose) {",
			"    return LazySegTree<T, F, Combine, Compose>(n, identity, lazy_identity, combine, compose);",
			"}"
		],
		"description": "LazySegTree"
	},
	"ZFunc": {
		"prefix": "ZFUNC",
		"body": [
			"/**",
			" * Author: chilli",
			" * License: CC0",
			" * Description: z[x] computes the length of the longest common prefix of s[i:] and s,",
			" * except z[0] = 0. (abacaba -> 0010301)",
			" * Time: O(n)",
			" * Status: stress-tested",
			" */",
			"vi Z(const string& S) {",
			"	vi z(sz(S));",
			"	int l = -1, r = -1;",
			"	rep(i,1,sz(S)) {",
			"		z[i] = i >= r ? 0 : min(r - i, z[i - l]);",
			"		while (i + z[i] < sz(S) && S[i + z[i]] == S[z[i]])",
			"			z[i]++;",
			"		if (i + z[i] > r)",
			"			l = i, r = i + z[i];",
			"	}",
			"	return z;",
			"}"
		],
		"description": "ZFunc"
	},
	"SuffixArray": {
		"prefix": "SUFFIXARRAY",
		"body": [
			"/**",
			" * Author: 罗穗骞, chilli",
			" * Date: 2019-04-11",
			" * License: Unknown",
			" * Source: Suffix array - a powerful tool for dealing with strings",
			" * (Chinese IOI National team training paper, 2009)",
			" * Description: Builds suffix array for a string.",
			" * \\texttt{sa[i]} is the starting index of the suffix which",
			" * is $i$'th in the sorted suffix array.",
			" * The returned vector is of size $n+1$, and \\texttt{sa[0] = n}.",
			" * The \\texttt{lcp} array contains longest common prefixes for",
			" * neighbouring strings in the suffix array:",
			" * \\texttt{lcp[i] = lcp(sa[i], sa[i-1])}, \\texttt{lcp[0] = 0}.",
			" * The input string must not contain any zero bytes.",
			" * Time: O(n \\log n)",
			" * Status: stress-tested",
			" */",
			"struct SuffixArray {",
			"	vi sa, lcp;",
			"	SuffixArray(string& s, int lim=256) { // or basic_string<int>",
			"		int n = sz(s) + 1, k = 0, a, b;",
			"		vi x(all(s)+1), y(n), ws(max(n, lim)), rank(n);",
			"		sa = lcp = y, iota(all(sa), 0);",
			"		for (int j = 0, p = 0; p < n; j = max(1, j * 2), lim = p) {",
			"			p = j, iota(all(y), n - j);",
			"			rep(i,0,n) if (sa[i] >= j) y[p++] = sa[i] - j;",
			"			fill(all(ws), 0);",
			"			rep(i,0,n) ws[x[i]]++;",
			"			rep(i,1,lim) ws[i] += ws[i - 1];",
			"			for (int i = n; i--;) sa[--ws[x[y[i]]]] = y[i];",
			"			swap(x, y), p = 1, x[sa[0]] = 0;",
			"			rep(i,1,n) a = sa[i - 1], b = sa[i], x[b] =",
			"				(y[a] == y[b] && y[a + j] == y[b + j]) ? p - 1 : p++;",
			"		}",
			"		rep(i,1,n) rank[sa[i]] = i;",
			"		for (int i = 0, j; i < n - 1; lcp[rank[i++]] = k)",
			"			for (k && k--, j = sa[rank[i] - 1];",
			"					s[i + k] == s[j + k]; k++);",
			"	}",
			"};"
		],
		"description": "SuffixArray"
	},
	"AhoCorasick": {
		"prefix": "AHOCORASICK",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2015-02-18",
			" * License: CC0",
			" * Source: marian's (TC) code",
			" * Description: Aho-Corasick automaton, used for multiple pattern matching.",
			" * Initialize with AhoCorasick ac(patterns); the automaton start node will be at index 0.",
			" * find(word) returns for each position the index of the longest word that ends there, or -1 if none.",
			" * findAll($-$, word) finds all words (up to $N \\sqrt N$ many if no duplicate patterns)",
			" * that start at each position (shortest first).",
			" * Duplicate patterns are allowed; empty patterns are not.",
			" * To find the longest words that start at each position, reverse all input.",
			" * For large alphabets, split each symbol into chunks, with sentinel bits for symbol boundaries.",
			" * Time: construction takes $O(26N)$, where $N =$ sum of length of patterns.",
			" * find(x) is $O(N)$, where N = length of x. findAll is $O(NM)$.",
			" * Status: stress-tested",
			" */",
			"struct AhoCorasick {",
			"	enum {alpha = 26, first = 'A'}; // change this!",
			"	struct Node {",
			"		// (nmatches is optional)",
			"		int back, next[alpha], start = -1, end = -1, nmatches = 0;",
			"		Node(int v) { memset(next, v, sizeof(next)); }",
			"	};",
			"	vector<Node> N;",
			"	vi backp;",
			"	void insert(string& s, int j) {",
			"		assert(!s.empty());",
			"		int n = 0;",
			"		for (char c : s) {",
			"			int& m = N[n].next[c - first];",
			"			if (m == -1) { n = m = sz(N); N.emplace_back(-1); }",
			"			else n = m;",
			"		}",
			"		if (N[n].end == -1) N[n].start = j;",
			"		backp.push_back(N[n].end);",
			"		N[n].end = j;",
			"		N[n].nmatches++;",
			"	}",
			"	AhoCorasick(vector<string>& pat) : N(1, -1) {",
			"		rep(i,0,sz(pat)) insert(pat[i], i);",
			"		N[0].back = sz(N);",
			"		N.emplace_back(0);",
			"",
			"		queue<int> q;",
			"		for (q.push(0); !q.empty(); q.pop()) {",
			"			int n = q.front(), prev = N[n].back;",
			"			rep(i,0,alpha) {",
			"				int &ed = N[n].next[i], y = N[prev].next[i];",
			"				if (ed == -1) ed = y;",
			"				else {",
			"					N[ed].back = y;",
			"					(N[ed].end == -1 ? N[ed].end : backp[N[ed].start])",
			"						= N[y].end;",
			"					N[ed].nmatches += N[y].nmatches;",
			"					q.push(ed);",
			"				}",
			"			}",
			"		}",
			"	}",
			"	vi find(string word) {",
			"		int n = 0;",
			"		vi res; // ll count = 0;",
			"		for (char c : word) {",
			"			n = N[n].next[c - first];",
			"			res.push_back(N[n].end);",
			"			// count += N[n].nmatches;",
			"		}",
			"		return res;",
			"	}",
			"	vector<vi> findAll(vector<string>& pat, string word) {",
			"		vi r = find(word);",
			"		vector<vi> res(sz(word));",
			"		rep(i,0,sz(word)) {",
			"			int ind = r[i];",
			"			while (ind != -1) {",
			"				res[i - sz(pat[ind]) + 1].push_back(ind);",
			"				ind = backp[ind];",
			"			}",
			"		}",
			"		return res;",
			"	}",
			"};"
		],
		"description": "AhoCorasick"
	},
	"PowerMod": {
		"prefix": "POWERMOD",
		"body": [
			"int power(int x, int y) {",
			"    int res = 1;",
			"    while (y) {",
			"        if (y & 1) {",
			"            res = res * 1LL * x % mod;",
			"        }",
			"        x = x * 1LL * x % mod;",
			"        y >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "PowerMod"
	},
	"KMP": {
		"prefix": "KMP",
		"body": [
			"/**",
			" * Author: Johan Sannemo",
			" * Date: 2016-12-15",
			" * License: CC0",
			" * Description: pi[x] computes the length of the longest prefix of s that ends at x,",
			" * other than s[0...x] itself (abacaba -> 0010123).",
			" * Can be used to find all occurrences of a string.",
			" * Time: O(n)",
			" * Status: Tested on kattis:stringmatching",
			" */",
			"vi pi(const string& s) {",
			"	vi p(sz(s));",
			"	rep(i,1,sz(s)) {",
			"		int g = p[i-1];",
			"		while (g && s[i] != s[g]) g = p[g-1];",
			"		p[i] = g + (s[i] == s[g]);",
			"	}",
			"	return p;",
			"}"
		],
		"description": "KMP"
	},
	"BiComps": {
		"prefix": "BICOMPS",
		"body": [
			"/*",
			" * 1-index, vertices 1 -> sz(g) - 1",
			" * Usage:",
			" *  int eid = 0; g.resize(N);",
			" *  for each edge (a,b) {",
			" *    g[a].emplace_back(b, eid);",
			" *    g[b].emplace_back(a, eid++); ",
			" *  }",
			" *  vector<vi> comps;",
			" *  bicomps(g, [&](const vi &edgeList) {",
			" *      comps.push_back(edgeList);",
			" *  });",
			"*/",
			"template<class F>",
			"void bicomps(vector<vector<ii>> &g, F f) {",
			"    vi num, st;",
			"    int Time;",
			"    num.assign(sz(g), 0);",
			"    function<int(int, int, F&)> dfs = [&](int at, int par, F &t) {",
			"        int me = num[at] = ++Time, e, y, top = me;",
			"        for (auto pa : g[at]) if (pa.second != par) {",
			"            tie(y, e) = pa;",
			"            if (num[y]) {",
			"                top = min(top, num[y]);",
			"                if (num[y] < me)",
			"                    st.push_back(e);",
			"            } else {",
			"                int si = sz(st);",
			"                int up = dfs(y, e, f);",
			"                top = min(top, up);",
			"                if (up >= me) {",
			"                    // up > me: edge at->y is a bridge",
			"                    st.push_back(e);",
			"                    f(vi(st.begin() + si, st.end()));",
			"                    st.resize(si);",
			"                }",
			"                else if (up < me) st.push_back(e);",
			"            }",
			"        }",
			"        return top;",
			"	};",
			"	rep(i,1,sz(g)) if (!num[i]) dfs(i, -1, f);",
			"}"
		],
		"description": "BiComps"
	},
	"SIEVE": {
		"prefix": "SIEVE",
		"body": [
			"const int N = 10000000;",
			"vector<int> lp(N+1);",
			"vector<int> pr;",
			"",
			"for (int i = 2; i <= N; ++i) {",
			"    if (lp[i] == 0) {",
			"        lp[i] = i;",
			"        pr.push_back(i);",
			"    }",
			"    for (int j = 0; i * pr[j] <= N; ++j) {",
			"        lp[i * pr[j]] = pr[j];",
			"        if (pr[j] == lp[i]) {",
			"            break;",
			"        }",
			"    }",
			"}"
		],
		"description": "SIEVE"
	},
	"CHT-Fast": {
		"prefix": "CHT-FAST",
		"body": [
			"/**",
			" * O(N) DP Convex Hull Trick. Get minimum of a*x + b. ",
			" * (If maximum, flip to -a*x - b instead)",
			" * add(a, b) must be called with increasing order of a.",
			" * (use add(-a, b) if a is decreasing)",
			" * query(x) must be called with increasing order of x.",
			" * (use query(-x) if x is decreasing, else use queryBS(x))",
			" */",
			"struct CHT {",
			"    using II = pair<ll, ll>;",
			"    deque<II> deq;",
			"",
			"    bool check(II x, II y, II z) {",
			"        return (y.fi - x.fi) * (z.se - y.se) >= (y.se - x.se) * (z.fi - y.fi);",
			"    }",
			"",
			"    void add(int a, ll b) {",
			"        II f(a, b);",
			"        while (deq.size() >= 2 && check(f, deq[0], deq[1])) {",
			"            deq.pop_front();",
			"        }",
			"        deq.push_front(f);",
			"    }",
			"",
			"    ll query(int x) {",
			"        while (deq.size() >= 2 && deq[0].fi * x + deq[0].se >=",
			"                                      deq[1].fi * x + deq[1].se) {",
			"            deq.pop_front();",
			"        }",
			"        return deq[0].fi * x + deq[0].se;",
			"    }",
			"",
			"    ll queryBS(int x) {",
			"        int l = 0, r = (int) deq.size() - 1;",
			"        while (l != r) {",
			"            int mi = (l + r) >> 1;",
			"            if (deq[mi].fi * x + deq[mi].se > deq[mi + 1].fi * x + deq[mi + 1].se) l = mi + 1;",
			"            else r = mi;",
			"        }",
			"        return deq[l].fi * x + deq[l].se;",
			"    }",
			"};"
		],
		"description": "CHT-Fast"
	},
	"CHT": {
		"prefix": "CHT",
		"body": [
			"/**",
			" * Author: Simon Lindholm",
			" * Date: 2017-04-20",
			" * License: CC0",
			" * Source: own work",
			" * Description: Container where you can add lines of the form kx+m, and query maximum values at points x.",
			" *  Useful for dynamic programming (``convex hull trick'').",
			" * Time: O(\\log N)",
			" * Status: stress-tested",
			" */",
			"",
			"struct Line {",
			"	mutable ll k, m, p;",
			"	bool operator<(const Line& o) const { return k < o.k; }",
			"	bool operator<(ll x) const { return p < x; }",
			"};",
			"",
			"struct CHT : multiset<Line, less<>> {",
			"	// (for doubles, use inf = 1/.0, div(a,b) = a/b)",
			"	static const ll inf = LLONG_MAX;",
			"	ll div(ll a, ll b) { // floored division",
			"		return a / b - ((a ^ b) < 0 && a % b); }",
			"	bool isect(iterator x, iterator y) {",
			"		if (y == end()) return x->p = inf, 0;",
			"		if (x->k == y->k) x->p = x->m > y->m ? inf : -inf;",
			"		else x->p = div(y->m - x->m, x->k - y->k);",
			"		return x->p >= y->p;",
			"	}",
			"	void add(ll k, ll m) {",
			"		auto z = insert({k, m, 0}), y = z++, x = y;",
			"		while (isect(y, z)) z = erase(z);",
			"		if (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
			"		while ((y = x) != begin() && (--x)->p >= y->p)",
			"			isect(x, erase(y));",
			"	}",
			"	ll query(ll x) {",
			"		assert(!empty());",
			"		auto l = *lower_bound(x);",
			"		return l.k * x + l.m;",
			"	}",
			"};"
		],
		"description": "CHT"
	},

	"Gen Test": {
	  "prefix": "GENTEST",
	  "body": [
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"",
		"const string NAME = \"A\";",
		"const int NTEST = 100;",
		"",
		"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
		"",
		"#define rd(l, r) uniform_int_distribution<long long>(l, r)(rng)",
		"",
		"void saveWrong(const string &inputFileName) {",
		"    int wrongTestCount = 1;",
		"    string wrongFileName;",
		"    do {",
		"        wrongFileName = NAME + \"_wrong_\" + to_string(wrongTestCount) + \".inp\";",
		"        wrongTestCount++;",
		"    } while (ifstream(wrongFileName).good());",
		"",
		"    ifstream src(inputFileName, ios::binary);",
		"    ofstream dst(wrongFileName, ios::binary);",
		"    dst << src.rdbuf();",
		"}",
		"",
		"void genTest(const string &inputFileName) {",
		"    ofstream inp(inputFileName.c_str());",
		"    // Implement me",
		"",
		"    inp.close();",
		"}",
		"int main()",
		"{",
		"    for (int iTest = 1; iTest <= NTEST; iTest++)",
		"    {",
		"        string inputFileName = NAME + \".inp\";",
		"        genTest(inputFileName);",
		"",
		"        system((\"./\" + NAME).c_str());",
		"        system((\"./\" + NAME + \"_brute\").c_str());",
		"",
		"        if (system((\"diff \" + NAME + \".out \" + NAME + \".ans\").c_str()) != 0)",
		"        {",
		"            cout << \"Test \" << iTest << \": WRONG!\\n\";",
		"            saveWrong(inputFileName);",
		"            return 0;",
		"        }",
		"        cout << \"Test \" << iTest << \": CORRECT!\\n\";",
		"    }",
		"    return 0;",
		"}",
		""
	  ],
	  "description": "Gen Test"
	}
}
